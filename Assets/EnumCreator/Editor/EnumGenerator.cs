using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace EnumCreator.Editor
{
    public static class EnumGenerator
    {
        const string GENERATED_PATH = "Assets/GeneratedEnums";

        public static void Generate(EnumCreator.EnumDefinition def)
        {
            try
            {
                if (def == null)
                {
                    Debug.LogError("EnumCreator: Cannot generate enum - definition is null");
                    return;
                }

                if (string.IsNullOrEmpty(def.EnumName))
                {
                    Debug.LogError("EnumCreator: Cannot generate enum - enum name is null or empty");
                    EditorUtility.DisplayDialog("Generation Error", 
                        "Cannot generate enum: Enum name is null or empty.", "OK");
                    return;
                }

                var settings = EnumCreatorSettingsManager.GetOrCreateSettings();
                string generatedPath = settings?.GeneratedEnumsPath ?? GENERATED_PATH;
                
                if (!Directory.Exists(generatedPath))
                {
                    try
                    {
                        Directory.CreateDirectory(generatedPath);
                    }
                    catch (System.Exception ex)
                    {
                        Debug.LogError($"EnumCreator: Failed to create directory '{generatedPath}': {ex.Message}");
                        EditorUtility.DisplayDialog("Generation Error", 
                            $"Failed to create directory '{generatedPath}':\n{ex.Message}", "OK");
                        return;
                    }
                }

                var file = Path.Combine(generatedPath, $"{def.EnumName}.cs");

                using (var writer = new StreamWriter(file))
                {
                // Auto-generated header (if enabled in settings)
                if (settings == null || settings.IncludeAutoGeneratedHeader)
                {
                    writer.WriteLine("// <auto-generated>");
                    writer.WriteLine("// Generated by EnumCreator Pro by Nicholas R. Gallo");
                    writer.WriteLine();
                }

                writer.WriteLine($"namespace {def.Namespace}");
                writer.WriteLine("{");

                // Use [System.Flags] only if the useFlags checkbox is checked
                if (def.UseFlags)
                    writer.WriteLine("    [System.Flags]");
                writer.WriteLine($"    public enum {def.EnumName}");
                writer.WriteLine("    {");

                // Process all values in their original order
                for (int i = 0; i < def.Values.Count; i++)
                {
                    var valueName = def.Values[i];
                    var name = Sanitize(valueName);
                    var tooltip = i < def.Tooltips.Count ? def.Tooltips[i] : "";
                    // Determine numbering scheme based on settings
                    int value;
                    if (def.UseFlags)
                    {
                        // Flags always use powers of 2
                        value = 1 << i;
                    }
                    else
                    {
                        // Unflagged enums use setting to determine numbering
                        if (settings?.UsePowersOfTwoForUnflagged == true)
                        {
                            value = 1 << i; // Powers of 2: 1, 2, 4, 8...
                        }
                        else
                        {
                            value = i; // Sequential: 0, 1, 2, 3...
                        }
                    }
                    
                    // Check if this value is disabled (in removed values)
                    bool isDisabled = def.RemovedValues.Contains(valueName);
                    
                    if (isDisabled)
                    {
                        // Mark as obsolete but keep the original numeric value
                        int removedIndex = def.MutableRemovedValues.IndexOf(valueName);
                        int originalValue = (removedIndex >= 0 && removedIndex < def.RemovedValueNumbers.Count) ? def.RemovedValueNumbers[removedIndex] : value;
                        writer.WriteLine($"        [System.Obsolete(\"{name} removed by designer\")]");
                        writer.WriteLine($"        {name} = {originalValue},");
                    }
                    else
                    {
                        // Normal value
                        if ((settings == null || settings.IncludeTooltips) && !string.IsNullOrWhiteSpace(tooltip))
                            writer.WriteLine($"        [UnityEngine.Tooltip(\"{tooltip}\")]");
                        writer.WriteLine($"        {name} = {value},");
                    }
                }

                writer.WriteLine("    }");
                writer.WriteLine("}");

                }

                AssetDatabase.Refresh();
            }
            catch (System.Exception ex)
            {
                Debug.LogError($"EnumCreator: Failed to generate enum '{def?.EnumName ?? "Unknown"}': {ex.Message}");
                EditorUtility.DisplayDialog("Generation Error", 
                    $"Failed to generate enum '{def?.EnumName ?? "Unknown"}':\n{ex.Message}", "OK");
            }
        }

        private static string Sanitize(string raw)
        {
            if (string.IsNullOrWhiteSpace(raw)) return "Unnamed";
            return raw.Replace(" ", "_");
        }


        private static int CalculateOriginalValue(EnumCreator.EnumDefinition def, int removedIndex)
        {
            if (def.UseFlags)
            {
                // For flags, use powers of 2: 1, 2, 4, 8, 16, 32, 64, 128...
                for (int power = 0; power < 10; power++) // Reasonable limit
                {
                    int value = 1 << power;
                    
                    // Check if this value is used by active values
                    bool usedByActive = false;
                    for (int i = 0; i < def.Values.Count; i++)
                    {
                        if ((1 << i) == value)
                        {
                            usedByActive = true;
                            break;
                        }
                    }
                    
                    // Check if this value is already used by removed values
                    bool usedByRemoved = false;
                    for (int i = 0; i < def.RemovedValueNumbers.Count; i++)
                    {
                        if (def.RemovedValueNumbers[i] == value)
                        {
                            usedByRemoved = true;
                            break;
                        }
                    }
                    
                    // If this value is not used, it's likely the original value
                    if (!usedByActive && !usedByRemoved)
                    {
                        return value;
                    }
                }
                
                // Fallback: use next available power of 2
                return 1 << (def.Values.Count + removedIndex);
            }
            else
            {
                // For regular enums, use sequential values: 0, 1, 2, 3, 4...
                for (int i = 0; i < 100; i++) // Reasonable limit
                {
                    // Check if this value is used by active values
                    bool usedByActive = false;
                    for (int j = 0; j < def.Values.Count; j++)
                    {
                        if (j == i)
                        {
                            usedByActive = true;
                            break;
                        }
                    }
                    
                    // Check if this value is already used by removed values
                    bool usedByRemoved = false;
                    for (int k = 0; k < def.RemovedValueNumbers.Count; k++)
                    {
                        if (def.RemovedValueNumbers[k] == i)
                        {
                            usedByRemoved = true;
                            break;
                        }
                    }
                    
                    // If this value is not used, it's likely the original value
                    if (!usedByActive && !usedByRemoved)
                    {
                        return i;
                    }
                }
                
                // Fallback: use high values
                return 1000 + removedIndex;
            }
        }
    }
}