using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace EnumCreator.Editor
{
    public static class EnumGenerator
    {
        const string GENERATED_PATH = "Assets/GeneratedEnums";
        const string TOOL_NAME = "EnumCreator v1.0";
        const string AUTHOR = "Nick";

        public static void Generate(EnumCreator.EnumDefinition def)
        {
            if (!Directory.Exists(GENERATED_PATH))
                Directory.CreateDirectory(GENERATED_PATH);

            var file = Path.Combine(GENERATED_PATH, $"{def.EnumName}.cs");

            using (var writer = new StreamWriter(file))
            {
                // Auto-generated header
                writer.WriteLine($"// <auto-generated by {TOOL_NAME} ï¿½ created by {AUTHOR}>");
                writer.WriteLine("// DO NOT EDIT MANUALLY");
                writer.WriteLine();

                writer.WriteLine($"namespace {def.Namespace}");
                writer.WriteLine("{");

                // Use [System.Flags] only if the useFlags checkbox is checked
                if (def.UseFlags)
                    writer.WriteLine("    [System.Flags]");
                writer.WriteLine($"    public enum {def.EnumName}");
                writer.WriteLine("    {");

                // Process all values in their original order
                for (int i = 0; i < def.Values.Count; i++)
                {
                    var valueName = def.Values[i];
                    var name = Sanitize(valueName);
                    var tooltip = i < def.Tooltips.Count ? def.Tooltips[i] : "";
                    int value = def.UseFlags ? (1 << i) : i; // Use powers of 2 for flags, sequential for regular
                    
                    // Check if this value is disabled (in removed values)
                    bool isDisabled = def.RemovedValues.Contains(valueName);
                    
                    if (isDisabled)
                    {
                        // Mark as obsolete but keep the original numeric value
                        int removedIndex = def.MutableRemovedValues.IndexOf(valueName);
                        int originalValue = (removedIndex >= 0 && removedIndex < def.RemovedValueNumbers.Count) ? def.RemovedValueNumbers[removedIndex] : value;
                        writer.WriteLine($"        [System.Obsolete(\"{name} removed by designer\")]");
                        writer.WriteLine($"        {name} = {originalValue},");
                    }
                    else
                    {
                        // Normal value
                        if (!string.IsNullOrWhiteSpace(tooltip))
                            writer.WriteLine($"        [UnityEngine.Tooltip(\"{tooltip}\")]");
                        writer.WriteLine($"        {name} = {value},");
                    }
                }

                writer.WriteLine("    }");
                writer.WriteLine("}");

            }

            AssetDatabase.Refresh();
        }

        private static string Sanitize(string raw)
        {
            if (string.IsNullOrWhiteSpace(raw)) return "Unnamed";
            return raw.Replace(" ", "_");
        }

        private static int CalculateOriginalValue(EnumCreator.EnumDefinition def, int removedIndex)
        {
            if (def.UseFlags)
            {
                // For flags, use powers of 2: 1, 2, 4, 8, 16, 32, 64, 128...
                for (int power = 0; power < 10; power++) // Reasonable limit
                {
                    int value = 1 << power;
                    
                    // Check if this value is used by active values
                    bool usedByActive = false;
                    for (int i = 0; i < def.Values.Count; i++)
                    {
                        if ((1 << i) == value)
                        {
                            usedByActive = true;
                            break;
                        }
                    }
                    
                    // Check if this value is already used by removed values
                    bool usedByRemoved = false;
                    for (int i = 0; i < def.RemovedValueNumbers.Count; i++)
                    {
                        if (def.RemovedValueNumbers[i] == value)
                        {
                            usedByRemoved = true;
                            break;
                        }
                    }
                    
                    // If this value is not used, it's likely the original value
                    if (!usedByActive && !usedByRemoved)
                    {
                        return value;
                    }
                }
                
                // Fallback: use next available power of 2
                return 1 << (def.Values.Count + removedIndex);
            }
            else
            {
                // For regular enums, use sequential values: 0, 1, 2, 3, 4...
                for (int i = 0; i < 100; i++) // Reasonable limit
                {
                    // Check if this value is used by active values
                    bool usedByActive = false;
                    for (int j = 0; j < def.Values.Count; j++)
                    {
                        if (j == i)
                        {
                            usedByActive = true;
                            break;
                        }
                    }
                    
                    // Check if this value is already used by removed values
                    bool usedByRemoved = false;
                    for (int k = 0; k < def.RemovedValueNumbers.Count; k++)
                    {
                        if (def.RemovedValueNumbers[k] == i)
                        {
                            usedByRemoved = true;
                            break;
                        }
                    }
                    
                    // If this value is not used, it's likely the original value
                    if (!usedByActive && !usedByRemoved)
                    {
                        return i;
                    }
                }
                
                // Fallback: use high values
                return 1000 + removedIndex;
            }
        }
    }
}
